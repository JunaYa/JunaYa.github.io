<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[OOM之Giraffe 记事本中使用ClipboardManager不当]]></title>
      <url>http://junaya.cn/2016/11/20/OOM%E4%B9%8BGiraffe-%E8%AE%B0%E4%BA%8B%E6%9C%AC%E4%B8%AD%E4%BD%BF%E7%94%A8ClipboardManager%E4%B8%8D%E5%BD%93/</url>
      <content type="text"><![CDATA[#记在“使用剪贴版快捷创建 note” 中使用不当造成的内存泄漏问题 项目地址 https://github.com/JunaYa/Giraffe 在提交版本中能看提交的历史，使用 LeakCanary 检测 在代码中我是如下实现 首先声明 ClipboardManager private ClipboardManager clipboard; 在 onCreateView() 中实例 ClipboardManager 并注册剪贴版监听事件 clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE); clipboard.addPrimaryClipChangedListener(onClipChangedListener); 相应的在 onDestroy() 中反注册监听 clipboard.removePrimaryClipChangedListener(onClipChangedListener); 剪贴板监听声明并实现内容监听的处理 private OnPrimaryClipChangedListener onClipChangedListener = new OnPrimaryClipChangedListener() { @Override public void onPrimaryClipChanged() { if (clipboard.hasPrimaryClip()){ if (clipboard.getPrimaryClipDescription().hasMimeType(MIMETYPE_TEXT_PLAIN)){ ClipData.Item item = clipboard.getPrimaryClip().getItemAt(0); String pasteData = item.getText().toString(); mSheetPaste.registerData(pasteData,mPagerAdapter.getConfig()); mSheetPaste.show(); } } } }; 开始写的时候，根本没考虑太多， 还是 too young ！请看图 当我操作点击 home 健出现的该问题 我又这样尝试做了一次实验 对于监听事件 onClipChangedListener 我在 onCreate() 中实力化； clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE); onClipChangedListener = new OnPrimaryClipChangedListener() { @Override public void onPrimaryClipChanged() { if (clipboard.hasPrimaryClip()){ if (clipboard.getPrimaryClipDescription().hasMimeType(MIMETYPE_TEXT_PLAIN)){ ClipData.Item item = clipboard.getPrimaryClip().getItemAt(0); String pasteData = item.getText().toString(); mSheetPaste.registerData(pasteData,mPagerAdapter.getConfig()); mSheetPaste.show(); } } } }; clipboard.addPrimaryClipChangedListener(onClipChangedListener); 同样多次操作 home 健，结果 并不能起什么作用。这到底怎么回事呢？ 然后有做了如下尝试， private class MyOnPrimaryClipChangedListener implements OnPrimaryClipChangedListener { @Override public void onPrimaryClipChanged() { if (clipboard.hasPrimaryClip()){ if (clipboard.getPrimaryClipDescription().hasMimeType(MIMETYPE_TEXT_PLAIN)){ ClipData.Item item = clipboard.getPrimaryClip().getItemAt(0); String pasteData = item.getText().toString(); mSheetPaste.registerData(pasteData,mPagerAdapter.getConfig()); mSheetPaste.show(); } } } }; 把事件监听写成内部类实现监听，然后 clipboard 使用该 clipboard.addPrimaryClipChangedListener(new MyOnPrimaryClipChangedListener()); 这样就没问题了，因为又注册所以必要的反注册 所以将内部类声明并实例化， clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE); mPrimaryClipChangedListener = new MyOnPrimaryClipChangedListener(); clipboard.addPrimaryClipChangedListener(mPrimaryClipChangedListener); @Override protected void onDestroy() { super.onDestroy(); clipboard.removePrimaryClipChangedListener(mPrimaryClipChangedListener); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[项目 Giraffe 记事本之 BottomSheetDialog 使用]]></title>
      <url>http://junaya.cn/2016/11/17/%E9%A1%B9%E7%9B%AE-Giraffe-%E8%AE%B0%E4%BA%8B%E6%9C%AC%E4%B9%8B-BottomSheetDialog-%E4%BD%BF%E7%94%A8/</url>
      <content type="text"><![CDATA[具体使用请查看项目中 项目 Giraffe 中的 BottomSheetWriter地址 使用 BottomSheetDialog 作为弹出控件传统的弹出框操作使用的有 PopuWindow 、 Dialog .项目中使用的是 BottomSheetDialog BottomSheetDialog 顾名思义， 它也是一个 Dialog ，一个可以从底部优雅的滑出来的一个 Dialog BottomSheetDialog extends AppCompatDialog AppCompatDialog extends Dialog 项目中使用 创建 BottomSheetWriter 来处理事件记录的界面和逻辑。使用了 Dagger ，一切使用起来简单又简洁。把它隔离开来。 在 BottomSheetWriter 中 声明BottomSheetDialog // 项目使用了 DataBinding private DialogEditBinding mBinding; private BottomSheetDialog mSheetDialog; 在构造函数中初始化 @Inject public BottomSheetWriter(@ActivityContext Context context) { View rootView = LayoutInflater.from(context).inflate(R.layout.dialog_edit, null); mBinding = DataBindingUtil.bind(rootView); mSheetDialog = new BottomSheetDialog(context, R.style.BottomSheetDialogStyle); mSheetDialog.setContentView(rootView); mSheetDialog.setCancelable(false); mSheetDialog.setCanceledOnTouchOutside(true); } 其中 R.style.BottomSheetDialogStyle 的内容为： &lt;style name=&quot;BottomSheetDialogStyle&quot; parent=&quot;Theme.Design.BottomSheetDialog&quot;&gt; &lt;item name=&quot;android:colorBackground&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;/style&gt; 主要是为了解决自己设置背景，比如要给整个 Dialog 弹出界面做成一个带有圆角的样式。 这时候，如果单纯给 rootView 一个背景 shape， 该 shape 设置它的 TopRight 和 TopLeft 的圆角。 但是会把应用自带的背景色显示出来。查看过 BottomSheetDialog 的 value 设置， windowBackground 并不起作用 ， 真正管理 BottomSheetDialog 的背景的是 android:colorBackground ，给它的值设置为透明即可。 BottomSheetDialog 方法 setCancelable(boolean cancelable) 返回键点击时候取消 setCanceledOnTouchOutside(boolean cancel)点击 BottomSheetDialog 外部是否允许取消 setContentView(View view)给 BottomSheetDialog 设置内容 view show() 显示 hide() 隐藏 dismiss() 事件处理当让这里肯定会有一些点击事件的处理。 因为项目中使用的 Realm 做存储 ，所以在 BottomSheetWriter 中拿到 Realm 将内容存储即可， 所以点击事件就在 BottomSheetWriter 中处理。如果跟 Activity 或者 Fragment 交互，需要自己写一个接口来做点击回调处理。 还有就是根据自己的需求进行设计，如果单纯的要拿 BottomSheetDialog 中的内容的话，可以给 BottomSheetDialog 传一个 TextView 或者 holder ，直接把点击事件要赋予的值设置给 Textview 或者 holder ，然后在 Activity／Fragment 中获取 TextView 的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[项目 Giraffe 记事本之剪贴板应用]]></title>
      <url>http://junaya.cn/2016/11/17/%E9%A1%B9%E7%9B%AE-Giraffe-%E8%AE%B0%E4%BA%8B%E6%9C%AC%E4%B9%8B%E5%89%AA%E8%B4%B4%E6%9D%BF%E5%BA%94%E7%94%A8/</url>
      <content type="text"><![CDATA[具体使用请查看项目中 项目地址 https://github.com/JunaYa/Giraffe 使用剪贴版快捷创建 note在其他应用中复制的内容将要作为 note 的 title 或者 content 。当用户把界面切换到 Giraffe 时，在 onResume() 中监听剪贴版的内容是否有改变。如果是新的内容，则将复制的内容作为 note 的 title 或者 content 由用户选择，默认是作为 title 使用，并且用户可以选择将要创建的 note 的 type 。用户点击 选择的创建类型后就会弹出创建 note 的操作，并且用户选择复制的内容放在 title 或 content 的输入位置，补充完整内容，就可以创建保存。 主要知识点官方文档 ClipboardManager 剪贴版内容可以有三种 URI 尽管允许任何 URI ，但是通常是 content provider URI Text ： 返回的是 CharSequence Intent ：此数据类型允许您将应用程序快捷方式复制到剪贴板。然后用户可以将快捷方式粘贴到其应用程序中以供将来使用 在项目中主要使用了其中的文字粘贴功能。参见代码： Interface to the clipboard service, for placing and retrieving text in the global clipboard.每次只能有一个数据在剪贴板上。 项目中的代码//获取 ClipboardManager ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE); // 构造出监听事件 OnPrimaryClipChangedListener onClipChangedListener = new OnPrimaryClipChangedListener() { @Override public void onPrimaryClipChanged() { // do something } }; // 给 clipboard 添加监听事件， clipboard.addPrimaryClipChangedListener(onClipChangedListener); // 注销监听事件 clipboard.removePrimaryClipChangedListener(onClipChangedListener); // 判断是否有内容 clipboard.hasPrimaryClip() // 内容是否为文本（项目中只用到该类型） clipboard.getPrimaryClipDescription().hasMimeType(MIMETYPE_TEXT_PLAIN) // 复制文本， 该 count 返回的一直是 1 int count = clipboard.getPrimaryClip().getItemCount(); // 获取到剪贴板内容 ClipData.Item item = clipboard.getPrimaryClip().getItemAt(0); // 获取内容里的真正文本 String pasteData = item.getText().toString(); // 自己的需求处理 mSheetPaste.registerData(pasteData,mPagerAdapter.getConfig()); mSheetPaste.show();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android ViewStub 的重复使用]]></title>
      <url>http://junaya.cn/2016/11/08/Android-ViewStub-%E7%9A%84%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8/</url>
      <content type="text"><![CDATA[在项目中使用的时候遇到的问题以及解决，做以记录。 项目文件地址https://github.com/JunaYa/Giraffe/blob/master/app/src/main/java/com/aya/giraffe/module/content/NoteListFragment.java 布局使用的是 DataBinding &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;viewModel&quot; type=&quot;com.aya.giraffe.module.content.NoteListViewModel&quot;/&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;ViewStub android:id=&quot;@+id/stub&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:inflatedId=&quot;@+id/subTree&quot; android:layout=&quot;@layout/stub_empty_view&quot;/&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; 这里所说的重复使用场景是，比如获取数据时，数据为空，或者数据请求出错。这是如果使用 ViewStub 的话，就要这样使用 mBinding.stub.getViewStub().inflate(); 因为我有删除操作，当我把数据清空时，需要再次显示空数据提示。因为 ViewStub 的作用就是 inflate 一次，就是把其中的 android:layout=”@layout/stub_empty_view” 布局添加到自己身上，把自己移除，当你再次想要 inflate 的时候，会返回一个空。这是只能通过操作已经添加上来的 view 来操纵显示隐藏或其他功能。 mBinding.stub.getRoot().setVisibility(View.GONE);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 后台开发之---小蓝图]]></title>
      <url>http://junaya.cn/2016/11/07/Java-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E4%B9%8B-%E5%B0%8F%E8%93%9D%E5%9B%BE/</url>
      <content type="text"><![CDATA[有机会能参与大神的自己项目，而且这个团队有这么对牛人。这是个非常好的机会。但是看到服务端的代码的时候，自己尝试看了看，也是这添加代码。结果没有跑通， 所以在网上查看了相关的资料。所以决定从开始把相关知识的学习，作为博客类似的笔记记录下来，分享于此，有助于推动自己的不断努力，也希望能帮助到想要一起学习 Java 后台开发的朋友。因为自己是做安卓开发的，对于 gradle 构建项目比较喜欢。所以学习的练习项目打算做一个自己的博客后台，后续可能会学习 react 前端，也可以把接口拿来使用。 自己最近也在学习 react-native 。学习的比较多， 这里一把手，那里又一把手，不亦乐乎。学习这些的时候呢比较喜欢做一个小项目来边学边做 ，因为语言规范好学 ，在用到的时候就可以学习。初期简单的过一遍就可以。在慕课网又看到一系列的 Java 开发课程，自己也在学习该课程。 从零开始的 Java 后台开发， 这一些列讲学习使用 [ ] Spring [ ] Spring Security [ ] Spring Boot [ ] Spring Web [ ] Spring JDBC [ ] Spring Boot Devtools [ ] Spring MVC [ ] Spring Actuator [ ] H2 [ ] MyBatis [x] MySQL]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 后台开发之-（MySQL for mac 的初识）]]></title>
      <url>http://junaya.cn/2016/11/07/MySQL-for-mac-%E7%9A%84%E5%88%9D%E8%AF%86/</url>
      <content type="text"><![CDATA[最近在重新学习搞起 Java 后台这块儿，因为想跟大神么一起做点事情，所以必须学起来。这一系列的笔记将会记录自己所学习后台开发这些点滴，这样记录下来有助于自己以后查看，也希望能帮到跟我一样的朋友，从零开始的异世界 ，no ， 是从零开始的 Java 后台开发。今天把数据安装完毕， 试了试简单的 SQL 语句。 install点击安装就 OK 安装完毕的弹出提示要切记，把密码记下，登录时需要密码 2016-11-06T03:27:25.257692Z 1 [Note] A temporary password is generated for root@localhost: U0:E5evpyZ&amp;N change password但是每次登录比较费事，生成的密码太繁琐，也不可能每次都输入一大串。所以需要修改密码，方便登录登录首先把秘密清除，永远不输入密码，然后会提示设置密码，这样再设置自己的密码 ALTER USER &apos;root&apos;@&apos;localhost&apos; PASSWORD EXPIRE NEVER; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;your-new-password&apos;); 前后安装了有 6，7 回， 汗！ uninstall再安装过程中，有忘记记录密码的，可以卸载重新安装，很快的，但是要切记记下密码区，其中有的没有被创建，忽略 sudo rm /usr/local/mysql sudo rm -rf /usr/local/mysql* sudo rm -rf /Library/StartupItems/MySQLCOM sudo rm -rf /Library/PreferencePanes/My* sudo rm -rf /Library/Receipts/mysql* sudo rm -rf /Library/Receipts/MySQL* sudo rm -rf /var/db/receipts/com.mysql.* 基本语法sql 语句结束要以 ; 符号结尾，不然会出现 -&gt; 。 不区分大小写 查看创建了多少数据库show Databases; ##3 创建数据库 create database 数据库名 character set gbk // character set gbk 设定数据库字符编码格式为 gbk 选择所要操作的数据库选择使用数据库有两种方法 // 登录前 mysql -D 数据库名 -u root -p // 登录后 use 数据库名 展示当前数据库的表结构show tables 查看表创建的过程show create table 表名 创建表CREATE TABLE student ( uid INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, username VARCHAR(255) NOT NULL UNIQUE, mobile VARCHAR(255) UNIQUE, password VARCHAR(255) NOT NULL, appId INT DEFAULT 1, loginAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP, expiresAt TIMESTAMP, isLocked BOOLEAN DEFAULT FALSE ); int 指定该列的数据类型为 int 取值范围为 -8388608到8388607 unsigned 无符号型 AUTO_INCREMENT 自动增长 NOT NULL 不为空 UNIQUE 唯一约束 DEFAULT 允许传入为空，但是会提供一个默认数据， 对已经创建好的表，对字段添加约束 ALTER TABLE student ADD unique(`username`); 插入数据insert into 表名 (列名1, 列名2, 列名3, ...) values (值1, 值2, 值3, ...); 删除表中的数delete from 表名称 where 删除条件; 更新表中的数据update 表名称 set 列名称1=新值 , 列名称2=新值 where 更新条件; 查询表中的数据select 列名称 from 表名称 查询条件; 删除表drop table 表名称; 最后，复杂的 SQL 语句在项目中会使用到。项目开始的时候会把练习项目放到 GitHub 上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序算法]]></title>
      <url>http://junaya.cn/2016/11/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      <content type="text"><![CDATA[参考有直观的排序过程，多种语言 交换排序冒泡public static void bubbleSort(int[] array) { int len = array.length; for (int i = 0; i &lt; len; i++) { for (int j = 1; j &lt; len - i; j++) { if (array[j - 1] &gt; array[j]) { int temp = array[j - 1]; array[j - 1] = array[j]; array[j] = temp; } } } } 持续比较相邻元素，大的挪到后面，因此大的会逐步往后挪平均情况与最坏情况均为 $O(n^2)$ , 使用了 temp 作为临时交换变量，空间复杂度为 O(1) 插入排序 public static void insertionSort(int[] array) { int len = array.length; int i = 0 ; for ( i = 0; i &lt; len; i++) { int index = i, array_i = array[i]; while (index &gt; 0 &amp;&amp; array[index - 1] &gt; array_i) { array[index] = array[index - 1]; index -= 1; } array[index] = array_i; } } 1,从第一个元素开始，该元素可认为已排序2,取下一个元素，对已排序数组从后往前扫描3,若从排序数组中取出的元素大于新元素，则移至下一位置4,重复步骤3，直至找到已排序元素小于或等于新元素的位置5,插入新元素至该位置6,重复2~5 选择排序伪代码 void SelectedSort(int List[] , int N){ //将 N 个整数 List[0] ... List[N] 进行递减排序 for ( i = 0 ; i &lt; N ; l ++ ){ MinPosition = findMin( List ,i , N-1 ); // 从 List [i] 到 list[N-1] 中找最小元，并把它的位置给 MinPosition Swap（ List[i] ,List[MinPositino] ); // 将未排序部分的最小元换到这部分最后位置 } } public static void selectionSort(int[] array) { int len = array.length; int i = 0, j = 0; for ( i = 0 ; i &lt; len; i++) { int min_index = i; for ( j = i + 1; j &lt; len; j++) { if (array[j] &lt; array[min_index]) { min_index = j; } } int temp = array[min_index]; array[min_index] = array[i]; array[i] = temp; } } 不断地选择剩余元素中的最小者1,找到数组中最小元素并将其和数组第一个元素交换位置。2,在剩下的元素中找到最小元素并将其与数组第二个元素交换，直至整个数组排序。 比较次数=(N-1)+(N-2)+(N-3)+…+2+1~N^2/2交换次数=N运行时间与输入无关数据移动最少 快速排序public static void quickSort(int[] array) { quickSort(array, 0, array.length - 1); } public static void quickSort(int[] array, int l, int u) { if (l &gt;= u) return; int m = l; for (int i = l + 1; i &lt;= u; i++) { if (array[i] &lt; array[l]) { m += 1; int temp = array[m]; array[m] = array[i]; array[i] = temp; } } // swap between array[m] and array[l] // put pivot in the mid int temp = array[m]; array[m] = array[l]; array[l] = temp; quickSort(array, l, m - 1); quickSort(array, m + 1, u); } 1,定基准——首先随机选择一个元素最为基准2,划分区——所有比基准小的元素置于基准左侧，比基准大的元素置于右侧3,递归调用——递归地调用此切分过程 归并排序分而治之原地归并 public static void mergeSort(int[] array) { sort(array, 0, array.length - 1); } public static void sort(int[] array, int low, int high) { if (high &lt;= low) return; int mid = low + (high - low) / 2; sort(array, low, mid); sort(array, mid + 1, high); merge(array, low, mid, high); } private static void merge(int[] array, int low, int mid, int high) { int[] helper = new int[array.length]; // copy array to helper for (int k = low; k &lt;= high; k++) { helper[k] = array[k]; } // merge array[low...mid] and array[mid + 1...high] int i = low, j = mid + 1; for (int k = low; k &lt;= high; k++) { // k means current location if (i &gt; mid) { // no item in left part array[k] = helper[j]; j++; } else if (j &gt; high) { // no item in right part array[k] = helper[i]; i++; } else if (helper[i] &gt; helper[j]) { // get smaller item in the right side array[k] = helper[j]; j++; } else { // get smaller item in the left side array[k] = helper[i]; i++; } } } 堆排序public void sort(int[] nums, boolean ascending) { if (ascending) { // build max heap maxHeap(nums, nums.length); // heap sort for (int i = nums.length - 1; i &gt;= 0; i--) { int temp = nums[0]; nums[0] = nums[i]; nums[i] = temp; // reconstruct max heap maxHeap(nums, i); } } else { // build min heap minHeap(nums, nums.length); // heap sort for (int i = nums.length - 1; i &gt;= 0; i--) { int temp = nums[0]; nums[0] = nums[i]; nums[i] = temp; // reconstruct min heap minHeap(nums, i); } } } // sign = 1 ==&gt; min-heap, sign = -1 ==&gt; max-heap private void siftDown(int[] nums, int k, int size, int sign) { int half = (size &gt;&gt;&gt; 1); while (k &lt; half) { int index = k; // left leaf node search int l = (k &lt;&lt; 1) + 1; if (l &lt; size &amp;&amp; (sign * nums[l]) &lt; (sign * nums[index])) { index = l; } // right leaf node search int r = l + 1; if (r &lt; size &amp;&amp; (sign * nums[r]) &lt; (sign * nums[index])) { index = r; } // already heapify if (k == index) break; // keep the root node the smallest/largest int temp = nums[k]; nums[k] = nums[index]; nums[index] = temp; // adjust next index k = index; } } private void minHeap(int[] nums, int size) { heapify(nums, size, 1); } private void maxHeap(int[] nums, int size) { heapify(nums, size, -1); } private void heapify(int[] nums, int size, int sign) { for (int i = size / 2; i &gt;= 0; i--) { siftDown(nums, i, size, sign); } } [ ] 希尔 [ ] 线性排序 [ ] 桶排序 查找算法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 基础]]></title>
      <url>http://junaya.cn/2016/11/05/Java-%E5%9F%BA%E7%A1%80/</url>
      <content type="text"><![CDATA[int 和 IntegerJava 中的数据类型分为基本数据类型和复杂数据类型从大的方面来说就是基本数据类型与其包装类的区别：int 是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象。如果要将 int 作为对象使用，需要使用 Integer 来声明对象。类似的还有：float Float;double Double使用范型ArrayList al=new ArrayList(); String StringBuffer StringBuilder String 字符串常量 StringBuffer 字符串变量（线程安全） StringBuilder 字符串变量（非线程安全） String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象由 final 修饰, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后,JVM 的 GC 就会开始工作，那速度是一定会相当慢的。 StringBuffer 线程安全的可变字符序列。每次对自己本身操作，不生成新对象。如果是 String s = “this “ + “is “ +” string” ;, 那么在 JVM 中就会按照 String s = “this is string” ; 处理。如果是 for(String s:Strs){ temp += s; } //那么最好就是用 StringBuffer 来拼接。 StringBuffer buffer = new StringBuffer(); for(String s:Strs){ buffer.append(s); } StringBuilder 一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）,因为在大多数实现中，它比 StringBuffer 要快。 抽象类接口区别 对比 接口 抽象类 默认的方法实现 默认的方法实现完全是抽象的 不存在实现方法 实现 子类 extends 关键字，如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现 implement 关键字，需要提供接口中所有声明的方法的实现 构造器 可以有 不可以 与正常 Java 类的区别 除了不能实现抽象方法 ，其他相同 完全不同 访问修饰符 public、protected 和 default public main方法 有 main 方法并能运行 没有 多继承 只能有一个 可以有多个 速度 较快 较慢，需要时间去寻找在类中实现的方法 添加新方法 可以提供默认实现 必须改变实现接口类 HashMap HashTable 对比 HashMap HashTable 继承实现 继承于AbstractMap,AbstractMap完成了Map接口 基于陈旧的Dictionary类，完成了Map接口 安全 非线程同步，不安全 线程同步，安全 对null的处理 值不允许 null 值允许 null ,(一个或多个健对应该值) 方法不同 contains(Object value) containsValue(Object value) 遍历 Enumeration Iterator 增长率 默认 11 ，old * 2+1 一定是2的指数 哈希值的使用 直接使用对象的hashCode 重新计算hash值，而且用与代替求模 ArrayMap 用两个数组来模拟Map，第一个数组存放存放item的hash值，第二数组是把key，value连续的存放在数组里，通过先算hash在第一个数组里找到它的hash index，根据这个index在去第二个数组里找到这个key-value。 ArrayList LinkedList1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构]]></title>
      <url>http://junaya.cn/2016/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="text"><![CDATA[#数据结构 逻辑结构集合一组属性相同的元素的集合 线性结构一对一 树形结构一对多 图形结构多对多 存储结构顺序存储 数据元素存储在一片连续的存储区域用数组实现，逻辑位置和物理位置保持一致 链式存储 非连续的存储结构，它的逻辑位置和物理位置不是保持一致的。节点保存的是该节点的值和逻辑关系指针 索引存储 存储元素时还新增了一个索引列表，列表每一项包含关键字和数据元素存储地址或存储域的首地址 散列（哈希）存储 数据元素存放在一片连续的存储区域，每一个数据元素具体地址根据该数据元素的关键字的值通过散列（哈希）函数计算出来 线性表线性表由 n (n&gt;=0)个数据元素所构成的有限序列线性表属于线性结构 开始节点（元素）没有前驱 终端节点（元素）没有后继 中间节点（元素）只有一个前驱和一个后继 线性表的顺序存储-顺序表 顺序存储的线性表 , 用一组地址连续的存储单元一次存放线性表中的数据元素 特点 线性表中逻辑上相邻的元素在物理地址上也是相邻的 存储密度高，需要预先分配足够的存储空间 便于随机存取 不便插入／删除 （会一起大量的数据元素的移动） 用数组描述，顺序存储结构 线性表的链式存储-链表 概念：链表是一种物理存储单元上非连续，非顺序的数据结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。组成：一系列节点组成，可以在运行时动态生成（列表中每一个元素称为节点）节点（元素）组成：1，存储数据的数据域2，存储下一个节点（元素）的指针域时间复杂度1，插入／删除 O（1）2，查找一个节点／访问特定编号节点 O（n）优点克服数组需要需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。缺点 没有数组随机读取优点，链表由于增加了节点指针域，空间开销表较大。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。类型 1，单向链表 链表的方向是单向的。head 指针指向第一个成为表头节点，最后一个指向 null 2，双向链表 没个数据节点中有两个指针，分别指向直接后继和直接前驱，从任意节点可以访问它的前驱节点和后继节点 3，循环链表最后一个指针域指向头节点，整个链表形成一个环 栈 只从一端进一端出 汉诺塔先进后出（FILO） ／ 后进先出（LIFO） 顺序栈 以数组实现如栈需要注意栈是否已满出栈需要注意栈是否为空 链式栈 以单链表实现 应用 ： 分割符匹配 ， 大数相加 ， 表达式求值 ， 栈与递归问题 队列 从一端进从另一端出 ，排队买票先进先出（FIFO) 循环顺序对列 数组实现需要注意判断是否为空是否已满，已满可能是假满1）少用一个存储单元，当容量为 maxSize ，队列空时 front == rear , 队列满时 front == (rear +1)%maxSize2)设置一个标记为，flag 初始值为 0， 当入队成功 flag=1 ，当出队成功 flag = 0 ， 所以当 队为空时 front == rear &amp;&amp; flag ==0 , 队列满时 front == rear &amp;&amp; flag = 1;3）设置一个变量 num 当入队成功 num + 1 ,当出队成功 num - 1 ,队列为空时 num == 0 ,队列满时 num &gt; 0 链队 单链表实现注意出队时判断是否为null ， 优先级队列 根据数据元素的优先级排队]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[格物致知]]></title>
      <url>http://junaya.cn/2016/10/29/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5/</url>
      <content type="text"><![CDATA[大学之道，在明明德，在亲民，在止于至善。知止而后有定；定而后能静；静而后能安；安而后能虑；虑而后能得。物有本末，事有终始。知所先后，则近道矣。古之欲明明德于天下者，先治其国；欲治其国者，先齐其家； 欲齐其家者，先修其身；欲修其身者，先正其心；欲正其心者，先诚其意；欲诚其意者，先致其知；致知在格物。 物格而后知至；知至而后意诚；意诚而后心正；心正而后身修；身修而后家齐；家齐而后国治；国治而后天下平。 自天子以至于庶人，壹是皆以修身为本。其本乱而未治者否矣。其所厚者薄，而其所薄者厚，未之有也！ 这是一篇在大学语文课本中的文章，当时还背诵过，也真的背诵了，在老师面前，只是背诵了。前段时间在找工作中，每次回来先到图书馆去，看看知识点，然后再回来。在二楼的一进门的图书室，前排的书架上摆放的大多是古文之类的，在浏览的时候，看到了厚厚的大学.中庸这本书。翻开的第一眼就是，大学之道。。。然后就悄声读了一遍，突然就被打动了。打动了自己的当前的一个状态，对于学习以及工作等其他，感觉真实给了自己人生的一个警醒，或者惊醒。回首自己的一年多的工作，也回首自己这一路走来索受的教育以及自己所学掌握知识的一个程度，再是反省自己的一个学习态度，自我认可程度，以及工作实际的检验。 今年算是自己的本命年吧，自己姑且这样安慰以下自己，是自己能力不行，智商跟不上情商也不够用。在面试的时候就完全显露出来。其实自己觉得这段时间成长了不少，反正自己肯定是能扛下来自己这个锅，对安卓以及知识的一个真正追求和渴望现在才自我明白。自己到底想要的是什么，并且确定自己要怎么走接下来的道路。但是，对于父母，自己真是于心不忍，一直以来他们都还没有明白我的工作是什么，也怪我没有讲明白。这段时间扰的父母也是一直担心我的工作，更是担心我的以后。他们当然是希望我能有一个安稳的生活和工作，起码他们的希望就是像公务员那样的生活，才算是稳定的。但是啊，我也终于明白自己为什么一直抵触体制的原因，但是就在中秋回家，亲人们的建议，我还心动了，毕竟他们讲到了人生的全部的规划。而我，最终也决定自己的追求，自己的所想要，渴望，目标。只是要安慰父母，让他们不要担心自己。 在次期间迷茫了很多，真的很多，但是也在一次次鼓励自己要自己努力下去。期间工作一年的时间里，对于自己进步并不是很大。因为这一年间接的认识了很多佼佼者，比如晓锋，还有许建林。前几个月还跟晓锋发了邮件，并且很亲切认真的回我邮件了，后续还会跟他发邮件，还有啊他又开源了几个项目，初识他的时候也是通过开源项目 MeiZi 而认识他，阅读了他的所有文章，所以才对他很感兴趣，所以微博 GitHub 博客都会经常去看。许建林呢 就更有趣了， 参加 GDG 活动时认识的他，进去就跟他挨着坐着，感觉有点面熟，没认出来。后来他上去分享演讲时，才想起来，是他分享 RxJava 的主题。当时我就尴尬了，后来也去他的博客上看了他的文章，每一篇都很认真的写，很有专研劲儿，而且特别高产，谁让他是高材生呢。讲的有点偏了，以后可以写写认识的每一个人。 大学期间没有真正的学习数据结构，现在做了一段时间的程序开发，再回过头来看这些基础知识，就会想到再语言中怎么使用，再哪些场景中使用。比如面试中定会有问道 ArrayList 和 LinkedList 的知识，他们的实现一个是用顺序存储实现线性表数据的存储，LinkedList 是由链表存储实现线性表数据存储，两者的区别就是 用于数据的操作场景下的不同， ArrayList 实现随机存取方便，但是插入删除耗费。 LinkedList 方便插入和删除操作，但是随机取某一元素都要从头开始找。 这样我就明白为什么在安卓中，获取数据的时候要用List dataList = new ArrayList()&lt;&gt;; 的使用原因。 所以呢，格物致知， 就是理解事物的底层，一层层的刨析原理这样才能建起高楼。这道理从小就开始接受，但是一直没能真正的领悟，这真理还得自己体会领悟。所以给自己的目标就是，从基础开始，回炉再造。这也是阅读了 《Android 艺术开发探索》得出来的感悟，因为要走远必须要有扎实的基础。这就是我的格物致知。]]></content>
    </entry>

    
  
  
</search>
